{"categories":[{"title":"算法","uri":"https://ousct.xyz/categories/%E7%AE%97%E6%B3%95/"}],"posts":[{"content":"做CMU-15-213的Lab的过程中发现，我在Mac OS下用make命令编译源代码会出错，错误如下：\nld: symbol(s) not found for architecture i386 clang: error: linker command failed with exit code 1 (use -v to see invocation) 错误说的是没有i386架构的支持，查看源代码的Makefile，确实有-m32的flag，也就是以32位架构进行编译 网上查询一番发现，Mac OS从10.14，即Mojave开始放弃了对32位架构的编译支持，也就是说虽然可以运行32位程序，但是不能编译\n解决方法如下： 在终端运行命令\nopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg 安装后就可以开启对32位的编译支持了，之后便可以正常编译32位程序，不过会抛出一条警告\nld: warning: The i386 architecture is deprecated for macOS (remove from the Xcode build setting: ARCHS) 编译器抱怨说i386架构已经被废弃啦\n参考：\n Can\u0026rsquo;t compile C program on a Mac after upgrade to Mojave\n ","id":0,"section":"posts","summary":"做CMU-15-213的Lab的过程中发现，我在Mac OS下用make命令编译源代码会出错，错误如下： ld: symbol(s) not found for architecture i386 clang: error: linker command failed with exit code 1 (use -v to","tags":null,"title":"Mac OS 开启32位编译支持","uri":"https://ousct.xyz/2020/05/mac-os-enable-32bit-lib/","year":"2020"},{"content":"安装Alfred之后发现搜索不到ntfs分区上的文件，后来发现Alfred文件搜索实际上是调用Spotlight，因此只要spotlight可以搜索ntfs分区就可以了\n默认情况下，spotlight不会对ntfs分区建立索引，因此需要手动开启。\nMac OS自动一个工具mdutil可以完成这个操作。\n使用-s参数可以查看一个分区的索引情况，如果这个分区没有索引会返回“Indexing disabled”：\n'\u0026rsquo;\u0026rsquo; mdutil -s /Volumes/DRIVE_NAME '\u0026rsquo;\u0026rsquo;\n可以用下面的命令开启一个分区的索引：\n'\u0026rsquo;\u0026rsquo; sudo mdutil -i on /Volumes/DRIVE_NAME '\u0026rsquo;\u0026rsquo; 这个时候你再用上面的-s命令就可以看到“Indexing enabled”了。如图：\n然后需要重建索引： '\u0026rsquo;\u0026rsquo; mdutil -E /Volumes/DRIVE_NAME '\u0026rsquo;\u0026rsquo;\n但是重建索引不会马上生效，需要重启一下，或者等操作系统的计划任务，总之过一段时间就可以了\n索引生效以后，spotlight就可以搜到ntfs分区上的文件了，Alfred也一样。\n 本文参考：How to index a NTFS partition on Mac\n ","id":1,"section":"posts","summary":"安装Alfred之后发现搜索不到ntfs分区上的文件，后来发现Alfred文件搜索实际上是调用Spotlight，因此只要spotlight","tags":null,"title":"Mac OS开启NTFS分区的索引","uri":"https://ousct.xyz/2020/02/mac-os-enable-ntfs-indexing/","year":"2020"},{"content":"二分算法的本质 我们经常把二分和单调性联系起来，实际上，二分和单调性并不是直接相关的。或者说，具有单调性的问题可以用二分来解决，而二分并不是只能解决具有单调性的问题，也就是说，单调性是二分的充分条件而非必要条件。\n那么，更加宽泛的来看，到底什么样的问题可以用二分来解决呢？\n可以这样描述，可以用二分来解决的问题具有这样的性质：\n在区间[l, r]上存在一种性质，能够将区间一分为二，一部分满足性质，另一部分不满足。\n对于区间是整数的二分问题而言，存在两种情况：也就是二分的边界点属于左半边的区间还是右半边的区间。\n如图所示：\n在这个图中，x是红色的，也就是说分界点x处于左边的区间\n在这个图中，x是绿色的，也就是说分界点x处在右边的区间\n二分算法模板 对应这两种情况，代码有所差异。因此可以衍生出两个版本的代码模板：\n首先，对于两种情况而言，基本的二分写法是不变的，算法每次迭代去区间点，即\nint mid = (l + r) / 2 然后检查中点是否满足性质(这里假设如果一个点是红色则check返回true)\nbool check(mid)  对于图一，也就是x属于红色的情况，这时如果check(mid) == true，那么mid处在红色区间， 那么分界点将会在mid右边，但是考虑到分界点也处在红色区间，因此mid也有可能就是 分界点，那么新的区间应该是[mid, r]；相应地，如果check(mid)为false，那么说明mid处 在绿色区间，那么分界点应该在mid的左边，由于分界点x属于红色，那么mid不可能是分界点 ，因此心的区间是[l, mid-1]代码如下：  while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } 对于图二，也就是x属于绿色的情况则和图一的情相反：如果check(mid)为true， 说明mid是红色，那么分界点将在将在mid的右边，但是由于分界点x是绿色， 所以mid不可能是分界点，因此新的区间是[mid + 1, r]；check(mid)为false的 情况以此类推，具体代码如下：  while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) l = mid + 1; else r = mid; } 注意到两个模板有一个细微的差别：对于图一，也就是x是红色的情况，在计算mid的时候 写的是\nmid = l + r + 1 \u0026gt;\u0026gt; 1; \u0026gt;\u0026gt;表示位运算的右移运算，右移一位即除以2，在除以2之前加+相当于上取整，这是什么操作？\n现在假设r = l + 1，也就是整个区间只有两个元素，如果采用下取整的除法（C++默认）， 那么得到的此时$$ mid = \\lfloor\\frac{l + r}{2}\\rfloor = \\lfloor\\frac{2l + 1}{2}\\rfloor = l $$ 新的区间[mid, r]就是[l, r]，也就是说区间没有得到更新，算法将陷入死循环。\n实际上，熟练以后并不需要对于这两个模板分别记忆，只需要注意一下，写代码的时候如果遇到\nl = mid 的时候，计算mid的时候加1即可。\n熟练使用这两个模板可以应对95%的整数二分算法题，剩下的5%的题属于不需要满足前文所提的一分为二的性质也可以使用二分的方法来解决，但是这类问题没有固定模板，需要见机行事。\n声明\n 本文所用的代码模板和思想来源于acwing\n ","id":2,"section":"posts","summary":"二分算法的本质 我们经常把二分和单调性联系起来，实际上，二分和单调性并不是直接相关的。或者说，具有单调性的问题可以用二分来解决，而二分并不是只","tags":["二分"],"title":"一招搞定95%的二分算法题","uri":"https://ousct.xyz/2019/07/2019-07-18-dichotomy/","year":"2019"},{"content":"一、矩阵创建 1. 从python list创建： \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; np.array([1,2,3]) array([1, 2, 3]) 2. 创建指定维度的矩阵 \u0026gt;\u0026gt;\u0026gt; np.ndarray([3,3]) array([[6.91547902e-310, 6.91547902e-310, 3.24515130e-109], [1.33360310e+241, 1.84714205e+241, 3.50129306e-311], [1.93049258e+241, 3.50129306e-311, 1.97869600e-293]]) 注意到此时的矩阵元素并没有被初始化为0，如果想要全0的矩阵，可以使用zeros函数\n\u0026gt;\u0026gt;\u0026gt; np.zeros([3,3]) array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) 类似的，还可以创建全1的矩阵\n\u0026gt;\u0026gt;\u0026gt; np.ones([3,3]) array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) numpy矩阵默认数据类型为float64， 可以指定为其他类型\n\u0026gt;\u0026gt;\u0026gt; np.ndarray([3,3]).dtype dtype(\u0026#39;float64\u0026#39;) \u0026gt;\u0026gt;\u0026gt; np.ones([3,3], dtype=int) array([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 3. 单位矩阵 \u0026gt;\u0026gt;\u0026gt; np.eye(3,3) array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) 4. 指定元素范围 \u0026gt;\u0026gt;\u0026gt; np.arange(1,10) array([1, 2, 3, 4, 5, 6, 7, 8, 9]) 5. 随机数矩阵 \u0026gt;\u0026gt;\u0026gt; np.random.random([3,3]) array([[0.87405393, 0.10697372, 0.76971393], [0.40052012, 0.61633898, 0.38150143], [0.68392246, 0.92883538, 0.16442259]]) 二、矩阵操作 1. reshape \u0026gt;\u0026gt;\u0026gt; np.arange(1,10).reshape([3,3]) array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 2. 合并 \u0026gt;\u0026gt;\u0026gt; a = np.arange(1,4) \u0026gt;\u0026gt;\u0026gt; a array([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; b = np.arange(4,7) \u0026gt;\u0026gt;\u0026gt; b array([4, 5, 6]) \u0026gt;\u0026gt;\u0026gt; np.stack((a, b))\t# 注意参数是一个元组 默认为按行堆叠 即axis=0 array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; np.stack((a, b), axis=1)\t#按列堆叠 array([[1, 4], [2, 5], [3, 6]]) \u0026gt;\u0026gt;\u0026gt; np.vstack((a,b)) array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; np.hstack((a,b)) array([1, 2, 3, 4, 5, 6]) 三、矩阵运算 1. 最大值、最小值、求和 \u0026gt;\u0026gt;\u0026gt; A = np.arange(1,10).reshape([3,3]) \u0026gt;\u0026gt;\u0026gt; A array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \u0026gt;\u0026gt;\u0026gt; A.max() 9 \u0026gt;\u0026gt;\u0026gt; A.min() 1 \u0026gt;\u0026gt;\u0026gt; A.sum() 45 注意默认情况下求的是整个矩阵的最大最小值以及和，可以指定axis按行或列计算\n\u0026gt;\u0026gt;\u0026gt; a.max(axis=0)\t# 求每一列的最大值 array([7, 8, 9]) \u0026gt;\u0026gt;\u0026gt; a.min(axis=1)\t# 求每一行的最小值 array([1, 4, 7]) 2. 矩阵加法 \u0026gt;\u0026gt;\u0026gt; a = np.arange(5) \u0026gt;\u0026gt;\u0026gt; a array([0, 1, 2, 3, 4]) \u0026gt;\u0026gt;\u0026gt; b = np.arange(5,10) \u0026gt;\u0026gt;\u0026gt; b array([5, 6, 7, 8, 9]) \u0026gt;\u0026gt;\u0026gt; a + b array([ 5, 7, 9, 11, 13]) \u0026gt;\u0026gt;\u0026gt; np.add(a, b) array([ 5, 7, 9, 11, 13]) 3. 矩阵乘法 \u0026gt;\u0026gt;\u0026gt; A = np.arange(1,10).reshape([3,3]) \u0026gt;\u0026gt;\u0026gt; A array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \u0026gt;\u0026gt;\u0026gt; I = np.eye(3,3) \u0026gt;\u0026gt;\u0026gt; I array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) \u0026gt;\u0026gt;\u0026gt; A.dot(I) array([[1., 2., 3.], [4., 5., 6.], [7., 8., 9.]]) \u0026gt;\u0026gt;\u0026gt; np.dot(A,I) array([[1., 2., 3.], [4., 5., 6.], [7., 8., 9.]]) element-wise 乘法\n\u0026gt;\u0026gt;\u0026gt; A * I array([[1., 0., 0.], [0., 5., 0.], [0., 0., 9.]]) 4. broadcast \u0026gt;\u0026gt;\u0026gt; a = np.arange(5) \u0026gt;\u0026gt;\u0026gt; a array([0, 1, 2, 3, 4]) \u0026gt;\u0026gt;\u0026gt; a + 1 array([1, 2, 3, 4, 5]) \u0026gt;\u0026gt;\u0026gt; a * 10 array([ 0, 10, 20, 30, 40]) 5. 转置 \u0026gt;\u0026gt;\u0026gt; A = np.arange(1,10).reshape([3,3]) \u0026gt;\u0026gt;\u0026gt; A array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \u0026gt;\u0026gt;\u0026gt; A.T array([[1, 4, 7], [2, 5, 8], [3, 6, 9]]) 6. 逆矩阵 \u0026gt;\u0026gt;\u0026gt; A = np.arange(1,5).reshape([2,2]) \u0026gt;\u0026gt;\u0026gt; A array([[1, 2], [3, 4]]) \u0026gt;\u0026gt;\u0026gt; np.linalg.inv(A) array([[-2. , 1. ], [ 1.5, -0.5]]) 7. 行列式 \u0026gt;\u0026gt;\u0026gt; A array([[1, 2], [3, 4]]) \u0026gt;\u0026gt;\u0026gt; np.linalg.det(A) -2.0000000000000004 ","id":3,"section":"posts","summary":"一、矩阵创建 1. 从python list创建： \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; np.array([1,2,3]) array([1, 2, 3]) 2. 创建指定维度的矩阵 \u0026gt;\u0026gt;\u0026gt; np.ndarray([3,3]) array([[6.91547902e-310, 6.91547902e-310, 3.24515130e-109], [1.33360310e+241, 1.84714205e+241, 3.50129306e-311], [1.93049258e+241, 3.50129306e-311, 1.97869600e-293]]) 注意到此时的矩阵元素并没有被初始化为","tags":null,"title":"Numpy备忘录","uri":"https://ousct.xyz/2018/09/2018-09-23-numpy-memo/","year":"2018"},{"content":"什么是形式化方法？ 形式化方法企图以数学的方式来描述软件系统，从而保证软件的正确性。\n 数学是准确的建模媒体，能够对现象、对象、动作等进行简洁、准确的描述；数学支持抽象，它使得规格的本质可以被展示出来，并且还可以以一种有组织的方式来表示系统规格中的抽象层次；数学提供了高层确认的手段，可以使用数学证明来揭示规格中的矛盾性和不完整性、以及用来展示设计和规格之间的一致情况。\n 形式化方法包括三个方面的活动：形式化规格、形式化验证以及程序求精（refinement）或转换。\n  形式化规格\n基于严格的数学（具有严格的语法和语义定义，可以准确的描述系统模型）来描述用户的需求、软件系统的功能以及各种性质。\n  形式化验证\n主要包括模型检验和定理证明：\n 模型检验： 基于有限状态模型并检验该模型的期望特性。(存在“状态爆炸问题”) 定理证明： 采用逻辑公式来规格系统及其性质。    程序求精\n又称程序变换，是将自动推理和形式化方法相结合而形成的一门新技术，它研究从抽象的形式规格推演出具体的面向计算机的程序代码的全过程。\n  典型的形式化方法   有限状态机\nFSM(Finite State Machine)，是关于存储量有限的计算机的基本模型，也是许多形式化方法规格和验证技术的基础模型。\n有限状态机的形式化定义为一个五元组 $M = (Q, \\Sigma, \\delta, q_0, F)$，具体定义如下：\n $ Q = \\{ q_0, q_1,\u0026hellip;,q_n \\} $, 有限状态集合。在任一确定时刻，FSM只能处于一个确定的状态$q_i$。 $\\Sigma = \\{\\sigma_1, \\sigma_2,\u0026hellip;,\\sigma_m\\}$, 有限输入字符集合。在任一确定的时刻，有限状态机只能接收一个确定的输入$\\sigma_j$。 $\\delta: Q \\times \\Sigma \\rightarrow Q$, 状态转移函数。如果在某一确定时刻，有限状态机处于某一状态$q_i \\in Q$，并接收一个输入字符$\\sigma_j \\in \\Sigma$，那么下一时刻处于一个确定的状态$q\u0026rsquo; = \\delta(q_i, \\sigma_j) \\in Q$。规定$q = \\sigma(q,\\epsilon)$，即任何状态下读入空字符时不发生任何状态转换。 $q_0 \\in Q$，初始状态。 $F \\subseteq Q$，终结状态集合。注意这里的$F$是一个集合，也就是说可以有多个状态作为终结状态，即当FSM的状态到达$F$集合中某个状态时就不再接收输入。  有限状态机的一个局限在于，仅有输入和状态转移，没有输出。对有限状态机进行扩展，引入输出可以得到Moore机和Mealy机。Moore机和Mealy机的不同主要在于：Moore机的输出仅与状态有关，二Mealy机的输出与状态和输入有关。\n  Moore机\nMoore机定义为六元组$M = (Q, \\Sigma, \\Delta, \\delta, \\lambda, q_0)$，其中：\n $Q = \\{q_0,q_1,\u0026hellip;,q_n\\}$，有限状态集合； $\\Sigma = \\{\\sigma_1, \\sigma_2,\u0026hellip;,\\sigma_m$，有限输入字符集合； $\\Delta = \\{ a_1, a_2, \u0026hellip;, a_r$，有限输出字符集合； $\\delta : Q \\times \\Sigma \\rightarrow Q$，状态转移函数； $\\lambda : Q \\rightarrow \\Delta$，输出函数； $q_0 \\in Q$ 初始状态。  注意，和FSM相比，除了定义了输出集合和输出函数意外，Moore机没有了终结状态，这就意味着Moore机不存在“接受”或“拒绝”一个输入的问题。l另外，也可以将FSM看做是Moore机的特例，其输出集合为$\\Delta = \\{0,1\\}$， 其输出函数为$$\\lambda (q) = \\begin{cases} 1, \u0026amp; \\text{if } q \\in F; \\\\ 0, \u0026amp; \\text{otherwise.} \\end{cases}$$\n  Mealy机\n同样地，Mealy机也定义为六元组，和Moore机相比，仅输出函数定义不同。 $\\lambda : Q \\times \\Sigma \\rightarrow \\Delta$\n    Petri网\nPetri网是用来描述并发、异步、分布式软件系统的形式化方法。\nPetri网，顾名思义是一种有向图。既是图，就有顶点和边。Petri网有两种顶点，位置（Place）和变迁（Transition），位置在上图中用圆圈表示，变迁则用竖线表示。Petri网的边只能连接两个不同的顶点，要么从位置到变迁，要么从变迁到位置，换言之，Petri网是一个二部图。另外，上图中位置圆圈内的点是（令牌）Token，表示资源。\nPetri网也可用代数表示，用一个五元组来描述$PN = (P,T, I, O, M_0)$，其中：\n $P = \\{p_1, p_2,\u0026hellip;,p_m\\}$，有限位置的集合； $T = \\{t_1, t_2, \u0026hellip;, t_n\\}$，有限变迁的集合，$P \\cap T = \\emptyset$ $I: P \\times T \\rightarrow \\{0, 1\\}$，输入函数（向前函数），对$\\forall p \\in P, \\forall t \\in T,$有$I(p, t) = 1 \\Leftrightarrow p$到$t$有边 $M_0 : P \\rightarrow \\{0,1,2,\u0026hellip;,w\\}，初始标示函数，$M_0(p) = k$表示$p$中有$k$个资源（token）。  一个变迁$t$对于给定标示函数$M$是可发射的，当且仅当$\\forall p \\in P, M(p) - I(p, t) \\geq 0$。（有资源才可发射）\n在标示函数$M_0下$，变迁$t$的发射是用一个新的标示函数$M_1$来代替$M_0$，记为$M_0 \\stackrel{t}{\\longrightarrow} M_1$，使得：对$\\forall p \\in P, M_1(p) = M_0(p) - I(p, t) + O(t, p)$，即$t$的发射使得$t$的每个输入位置令牌数减1，使每个输出位置的令牌数加1.\n可达性：若$M_0 \\stackrel{t_1}{\\longrightarrow}M_1\\stackrel{t_2}{\\longrightarrow}\u0026hellip;\\stackrel{t_k}{\\longrightarrow}M_k = M$则称$M_k$是$M_0$可达的，记为$M_0 \\stackrel{\\pi}{\\longrightarrow}M_k, \\pi = t_1 t_2\u0026hellip;t_k$\n下面是一个哲学家就餐的例子\n假设五位哲学家围坐在一张圆桌上，相邻哲学家共用一副筷子，如图所示\n每位哲学家共有两种状态：think和eat，一位进餐时需要同时获取左右两边的筷子，那么一个哲学家的情况表示成Petri网具有4个位置（两种状态和两边的餐具）和2个变迁（获取筷子和释放筷子）\n完整Petri网（初始状态，即五位哲学家均处于think状态）可表示为：\n  CSP\nCSP, Communicating Sequential Processes, 即通信顺序进程。CSP是一种描述并发系统的形式化语言。\nCSP 语法\n  // Assignment primitive \u0026lt;varible\u0026gt; := \u0026lt;expression\u0026gt; x := e // variable x takes on the value of expression e // Output primitive \u0026lt;destination process\u0026gt; ! \u0026lt;expression\u0026gt; A ! e // output the value of expression e to process A // Input primitive \u0026lt;source process\u0026lt; ? \u0026lt;variable\u0026gt; B ? x // from process B input to var x // Concurrent excution [\u0026lt;process\u0026gt; || \u0026lt;process\u0026gt; \u0026lt;|| \u0026lt;process\u0026gt; ... \u0026gt;] // Iteration *[...] // Dijkstra's Guarded Commands \u0026lt;guard\u0026gt; -\u0026gt; \u0026lt;commands\u0026gt; // the guard may be a Boolean expression or a result of I/O. // commands is a list of commands to be executed if the guard is true // Conditional Commands [ \u0026lt;guarded commands\u0026gt; [] \u0026lt;guarded commands\u0026gt; ... ] 例子：生产者/消费者 ``` Producer:: Buf ! P Consumer:: Buf ! more(); Buf ? P Buf::buffer:(0...9) in, out:integer; in := 0; out := 0; *[ in \u0026lt; out + 10; Producer ? buffer(in mod 10) -\u0026gt; in := in + 1 [] out \u0026lt; in; Consumer ? more() -\u0026gt; Consumer ! buffer(out mod 10) -\u0026gt; out := out + 1 ] ```  ","id":4,"section":"posts","summary":"什么是形式化方法？ 形式化方法企图以数学的方式来描述软件系统，从而保证软件的正确性。 数学是准确的建模媒体，能够对现象、对象、动作等进行简洁、准","tags":null,"title":"软件工程中的形式化方法小结","uri":"https://ousct.xyz/1/01/2019-06-21-formal-methods-in-software-engineering/","year":"0001"}],"tags":[{"title":"二分","uri":"https://ousct.xyz/tags/%E4%BA%8C%E5%88%86/"}]}